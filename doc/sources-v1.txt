
	"type": "book|website" <string: required>,
	"schema": <object: required> {
		"version": 1 <integer: required>
	},
	"title": "book title", <string: recommended>
	"id": "identifier-of-source", <string: number, letters or dashes only> /* the base name of the source JSON must match this. tables, etc. refer to this source by this id */
	"author": "author", <string: optional>
	"publisher": "publisher", <string: optional>
	"language": "lang", <string: optional>
	"copyright": <object: optional> {
		"year": 1988, <int: single year: optional>
		"by": "Thom Hogan" <string: optional>
	},
	"isbn": <object: optional> {
		"isbn-10": "1-55615-118-7", <object: optional>
		"isbn-13": "9-781556-151187" <object: optional>
	},
	"table of contents": <object: recommended if available> {
		"hierarchy": [ name, ... ], <array: optional, required if contents present, names must start with @ at sign>
		"contents": <object: optional> {
			"@name": <object> {
				"name": <object> {
					"title": "hierarchy level title", <string: required>
					"@name2": <object> {
						... and so on ...
					}
				}
			}
		}
	}

	The hierarchy array lists names (each starting with @) which names the
object key of the contents. The first one is from directly below the contents,
from which the keys of the object within are those entries at that level.
Each object within lists the title and then the second @ name in the
hierarchy. Each level until the depth of the hierarchy array is done. It is
allowed if the table of contents does not go to that depth not to provide it
there.

	If instead of the @ name there is a "group" object, then the group
provides the title and within the key. You may put a group in a group.
One good example is the PC Programmer's Guidebook, which represents the
subsection 1.1 hierarchy in the table of contents.

	The purpose of the schema object is to provide a version number. The
version number is bumped if somehow the schema must change in a manner
incompatible with prior code. It is not bumped if new information is added to
the schema in a way that is backwards compatible with old code i.e. does not
change anything already standardized by older code.

	The compiler for sources will add to the schema object the overall
version it supports which may be higher. At some point in the future when
a newer version is standard in the code the lower version number will indicate
that the code must convert the older schema to the new schema in the compiled
JSON.

	The compiler will also produce a "reference by" object, in which the
key will be the key of the table of contents at any level and within the
object will be a "path" object that directs downstream code how to navigate
down to the node, including entries which point to an index into groups. The
purpose of this object is for other code to resolve simple references. For
example, it is helpful if all a table has to do is say it came from book
"pc-programmers-sourcebook-1988" subsection "1.34" instead of having to repeat
the whole path every time. At compile time of the tables, the simple reference
will be converted, using the compiled source JSON, into the full path.

